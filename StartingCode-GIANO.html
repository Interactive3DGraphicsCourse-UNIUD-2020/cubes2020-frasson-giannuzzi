<html>

<head>
    <title>Giano CODE for first ASSIGNMENT</title>
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="lib/three.min.js"></script>
    <script src="lib/stats.min.js"></script>
    <script src="lib/Coordinates.js"></script>
    <script src="lib/OrbitControls.js"></script>
</head>

<body>

    <script>

        var scene, camera, renderer, controls, stats, data, data2, tempdata;
        var cube, line, geometry, mat, cubebox;
        var groundNumBoxX, groundNumBoxZ;
        var loadedHeighMap = false;

        //return array with height data from img, taken from: http://danni-three.blogspot.it/2013/09/threejs-heightmaps.html
        function getHeightData(img, scale) {

            if (scale == undefined) scale = 1;


            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var context = canvas.getContext('2d');

            var size = img.width * img.height;
            console.log(size);
            var data = new Float32Array(size);

            context.drawImage(img, 0, 0);

            for (var i = 0; i < size; i++) {
                data[i] = 0
            }

            var imgd = context.getImageData(0, 0, img.width, img.height);
            var pix = imgd.data;

            var j = 0;
            for (var i = 0; i < pix.length; i += 4) {
                var all = pix[i] + pix[i + 1] + pix[i + 2];  // all is in range 0 - 255*3
                data[j++] = scale * all / 3;
            }

            return data;
        }

        function Start() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x333333);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.gammaInput = true;
            renderer.gammaOutput = true;
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            camera.position.set(70, 50, 70);
            camera.lookAt(new THREE.Vector3(30, 10, 30));

            geometry = new THREE.BoxGeometry(1, 1, 1);
            cubebox = new THREE.Object3D();
            scene.add(cubebox);

            cubebox.position.x = -25;
            cubebox.position.z = -25;
            //var texture = new THREE.TextureLoader().load('textures/11635.jpg');
            //var material = new THREE.MeshPhongMaterial({ map: texture });
            //var material;
            //cube = new THREE.Mesh(geometry, material);
            //cube.castShadow = true;
            //cube.receiveShadow = true;
            //console.log(THREE.REVISION);
            //scene.add(cube);


            hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
            hemiLight.color.setHSL(0.6, 1, 0.6);
            hemiLight.groundColor.setHSL(0.095, 1, 0.75);
            hemiLight.position.set(0, 500, 0);
            scene.add(hemiLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.color.setHSL(0.1, 1, 0.95);
            dirLight.position.set(-1, 1.75, 1);
            dirLight.position.multiplyScalar(50);
            scene.add(dirLight);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;


            // GROUND
            /* var groundGeo = new THREE.PlaneBufferGeometry(10000, 10000);
             var groundMat = new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0x050505 });
             groundMat.color.setHSL(0.095, 1, 0.75);
             var ground = new THREE.Mesh(groundGeo, groundMat);
             ground.position.y = -0.5;
             ground.rotation.x = -Math.PI / 2;
             scene.add(ground);
             ground.receiveShadow = true;
             */

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            document.body.appendChild(stats.domElement);

            // uncomment if you need to draw coordinate axes when building the scene
            //Coordinates.drawAllAxes();

            controls = new THREE.OrbitControls(camera);
            controls.addEventListener('change', Render);
        }

        //Loader per tutte le immagini
        function Loader() {

            var imgLoader = new THREE.ImageLoader();

            // terrain
            var img = imgLoader.load(// resource URL
                "textures/heightmap3.png",

                // onLoad callback
                function (image) {
                    // use the image, e.g. draw part of it on a canvas
                    //get height data from img
                    data = getHeightData(image, 0.1);
                    console.log("data:", data);
                    tempdata = data;
                    //loadedHeighMap = true;

                    groundNumBoxX = img.width;
                    groundNumBoxZ = img.height;
                    // Start();
                },

                // onProgress callback currently not supported
                undefined,

                // onError callback
                function () {
                    console.error('An error happened.');
                }
            );

            var img = imgLoader.load(// resource URL
                "textures/heightmap4.png",

                // onLoad callback
                function (image) {
                    // use the image, e.g. draw part of it on a canvas
                    //get height data from img
                    data2 = getHeightData(image, 0.1);
                    console.log("data:", data);
                    loadedHeighMap = true;

                    groundNumBoxX = img.width;
                    groundNumBoxZ = img.height;
                    // Start();
                },

                // onProgress callback currently not supported
                undefined,

                // onError callback
                function () {
                    console.error('An error happened.');
                }
            );



        }

        function map_range(value, low1, high1, low2, high2) {
            return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
        }

        function Builder() {
            var i, j, k, l, m;
            var color, r, g, b;
            k = 0;
            //cube = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: 0xff0000 }));
            var deep, diff;
            for (i = 0; i < groundNumBoxX; i++) {
                for (j = 0; j < groundNumBoxZ; j++) {
                    cube = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: 0x000000, shininess: 97, specular: 0x20202 }));

                    cube.position.x = i;
                    cube.position.z = j;

                    //r = Math.floor(map_range(data[k], Math.min.apply(Math, data), Math.max.apply(Math, data), 0, 255));
                    //g = Math.floor(map_range(data[k], Math.min.apply(Math, data), Math.max.apply(Math, data), 0, 255));
                    //b = Math.floor(map_range(data[k], Math.min.apply(Math, data), Math.max.apply(Math, data), 0, 255));

                    var c = g = Math.floor(map_range(data[k], Math.min.apply(Math, data), Math.max.apply(Math, data), 0, 255));
                    c = (c.toString(16).length < 2 ? "0" : "") + c.toString(16);
                    cube.material.color.setHex("0X" + c + "" + c + "" + c);
                    cubebox.add(cube.clone());

                    for (l = 0; l < data[k]; l++) {
                        cube.position.y = data[k] - 1 - l;
                        //cubebox.add(cube.clone());
                    }
                    deep = Math.min(data[(groundNumBoxX * (i - 1)) + (j - 1)], data[(groundNumBoxX * (i - 1)) + (j)], data[(groundNumBoxX * (i - 1)) + (j + 1)],
                        data[(groundNumBoxX * (i)) + (j - 1)], data[(groundNumBoxX * (i)) + (j + 1)],
                        data[(groundNumBoxX * (i + 1)) + (j - 1)], data[(groundNumBoxX * (i + 1)) + (j)], data[(groundNumBoxX * (i + 1)) + (j + 1)]);

                    if (data[k] > deep) {
                        diff = data[k] - deep;
                        for (m = 0; m < diff; m++) {
                            cubett = cube.clone();
                            cubett.position.x = 0;
                            cubett.position.z = 0;
                            cubett.position.y = 0 - 1 - m;
                            cubett.material.color.setHex("0X" + c + c + c);
                            cubebox.children[k].add(cubett.clone());
                        }
                    }

                }
                k++;
            }
        }

        function new_builder() {
            var i, j, k, n;// i RIGHE, j COLONNE, k indice per tenere il conto e scorrere l'array delle altezze data
            k = 0;
            n = 0;
            //cube = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: 0xff0000 }));
            var deep, diff;
            for (i = 0; i < groundNumBoxX; i++) {
                for (j = 0; j < groundNumBoxZ; j++) {

                    cube = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0x333333 }));
                    line = new THREE.Line(geometry, new THREE.MeshBasicMaterial({ color: 0xff2299 }));
                    line.position.x = 0;
                    line.position.z = 0;
                    cube.position.x = i;
                    cube.position.z = j;
                    //cube.position.y = data[k];
                    var c = g = Math.floor(map_range(data[k], Math.min.apply(Math, data), Math.max.apply(Math, data), 0, 255));
                    c = (c.toString(16).length < 2 ? "0" : "") + c.toString(16);
                    cube.material.color.setHex("0X" + c + "" + c + "" + c);
                    //cube.add(line.clone());

                    cubebox.add(cube.clone());



                    deep = Math.min(
                        isNaN(data[(groundNumBoxX * (i - 1)) + (j - 1)]) ? 200 : data[(groundNumBoxX * (i - 1)) + (j - 1)],
                        isNaN(data[(groundNumBoxX * (i - 1)) + (j)]) ? 200 : data[(groundNumBoxX * (i - 1)) + (j)],
                        isNaN(data[(groundNumBoxX * (i - 1)) + (j + 1)]) ? 200 : data[(groundNumBoxX * (i - 1)) + (j + 1)],
                        isNaN(data[(groundNumBoxX * (i)) + (j - 1)]) ? 200 : data[(groundNumBoxX * (i)) + (j - 1)],
                        isNaN(data[(groundNumBoxX * (i)) + (j + 1)]) ? 200 : data[(groundNumBoxX * (i)) + (j + 1)],
                        isNaN(data[(groundNumBoxX * (i + 1)) + (j - 1)]) ? 200 : data[(groundNumBoxX * (i + 1)) + (j - 1)],
                        isNaN(data[(groundNumBoxX * (i + 1)) + (j)]) ? 200 : data[(groundNumBoxX * (i + 1)) + (j)],
                        isNaN(data[(groundNumBoxX * (i + 1)) + (j + 1)]) ? 200 : data[(groundNumBoxX * (i + 1)) + (j + 1)]
                    );
                    //DEBUGG
                    /*
                    if (i == 0 || j == 0 || i == groundNumBoxX - 1 || j == groundNumBoxZ - 1) {
                        console.log(isNaN(deep));
                    }*/
                    if (data[k] > deep) {
                        diff = Math.ceil(data[k] - deep);
                        //console.log(Math.ceil(diff));
                        for (m = 0; m < diff; m++) {
                            cubett = cube.clone();
                            cubett.position.x = 0;
                            cubett.position.z = 0;
                            cubett.position.y = 0 - 1 - m;
                            //cubett.material.color.setHex("0X" + c + c + c);
                            cubebox.children[k].add(cubett.clone());
                            
                        }
                        
                    }


                    k++;
                }
            }
            console.log(n);
        }

        function Builder_sample() {
            var i, j, k;// i RIGHE, j COLONNE, k indice per tenere il conto e scorrere l'array delle altezze data
            k = 0;
            //cube = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: 0xff0000 }));
            var deep, diff;
            for (i = 0; i < groundNumBoxX; i++) {
                for (j = 0; j < groundNumBoxZ; j++) {

                    cube = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: 0xf00f0, shininess: 97, specular: 0x20202 }));
                    cube.position.x = i;
                    cube.position.z = j;

                    var c = g = Math.floor(map_range(data[k], Math.min.apply(Math, data), Math.max.apply(Math, data), 0, 255));
                    c = (c.toString(16).length < 2 ? "0" : "") + c.toString(16);
                    cube.material.color.setHex("0X" + c + "" + c + "" + c);

                    cubebox.add(cube.clone());

                    k++;
                }
            }

        }

        function fix_holes() {
            var i, j, k, n;
            n=0;
            k = 0;
            console.log("YOLO");
            for (i = 0; i < groundNumBoxX; i++) {
                for (j = 0; j < groundNumBoxZ; j++) {
                    
                    deep = Math.min(
                        isNaN(data[(groundNumBoxX * (i - 1)) + (j - 1)]) ? 200 : data[(groundNumBoxX * (i - 1)) + (j - 1)],
                        isNaN(data[(groundNumBoxX * (i - 1)) + (j)]) ? 200 : data[(groundNumBoxX * (i - 1)) + (j)],
                        isNaN(data[(groundNumBoxX * (i - 1)) + (j + 1)]) ? 200 : data[(groundNumBoxX * (i - 1)) + (j + 1)],
                        isNaN(data[(groundNumBoxX * (i)) + (j - 1)]) ? 200 : data[(groundNumBoxX * (i)) + (j - 1)],
                        isNaN(data[(groundNumBoxX * (i)) + (j + 1)]) ? 200 : data[(groundNumBoxX * (i)) + (j + 1)],
                        isNaN(data[(groundNumBoxX * (i + 1)) + (j - 1)]) ? 200 : data[(groundNumBoxX * (i + 1)) + (j - 1)],
                        isNaN(data[(groundNumBoxX * (i + 1)) + (j)]) ? 200 : data[(groundNumBoxX * (i + 1)) + (j)],
                        isNaN(data[(groundNumBoxX * (i + 1)) + (j + 1)]) ? 200 : data[(groundNumBoxX * (i + 1)) + (j + 1)]
                    );

                    if (data[k] > deep) {
                        diff = Math.ceil(data[k] - deep);
                        
                        for (m = 0; m < diff; m++) {
                            cubett = cubebox.children[k].clone();
                            cubett.position.x = 0;
                            cubett.position.z = 0;
                            cubett.position.y = 0 - 1 - m;
                            //cubett.material.color.setHex("0X" + c + c + c);
                            cubebox.children[k].add(cubett.clone());
                            n++;
                        }
                    }
                    k++;
                }
            }
            console.log(n);
        }

        var done;
        var cubes_done = [];
        //la fun prende un boolean TRUE per alzare i quadretti FALSE per abbassarli
        function changeHeigh(upOrDown) {
            var o = 0;
            done = true;
            cubebox.children.forEach(element => {

                if (element.position.y < tempdata[o] && upOrDown) {
                    element.position.y += 1;
                } else if (element.position.y > 0 && !upOrDown) {
                    element.position.y -= 1;
                }
                o++;
            });
        }


        function Update() {
            requestAnimationFrame(Update);
            controls.update();
            stats.update();
            Render();
        }
        var time = new Date(0);
        var time2;
        var goHigh = false;
        //console.log(time);
        var move = false;
        function Render() {
            if (loadedHeighMap) {
                //console.log(data);
                console.log("Dim X:", groundNumBoxX);
                console.log("Dim Z:", groundNumBoxZ);
                new_builder();
                //Builder_sample();
                //cube.material.color.setHex(0xff00ff);
                loadedHeighMap = false;
                //fix_holes();
            }
            if (move) {

                time2 = new Date(0);
                if ((time - time2) % 2 == 0) {
                    changeHeigh(goHigh);
                    //move = !done;
                }
            }
            renderer.render(scene, camera);
        }

        Loader();
        Start();
        Update();

        document.onkeydown = function (e) {
            e = e || window.event;
            console.log(e.keyCode);
            switch (e.which || e.keyCode) {
                case 32: // left
                    goHigh = !goHigh;
                    move = true;
                    break;

                case 67: // up
                    tempdata = data;
                    console.log(tempdata);
                    break;

                case 86: // right
                    tempdata = data2;
                    console.log(tempdata);
                    break;

                case 40: // down
                    goHigh = false;
                    break;

                default: return; // exit this handler for other keys
            }
            e.preventDefault(); // prevent the default action (scroll / move caret)
        };

    </script>
</body>

</html>